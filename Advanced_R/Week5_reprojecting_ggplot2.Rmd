---
title: "Week5 - Spatial Points"
output: rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Reprojecting Raster data and plotting it with ggplot2

### Quick tutorial - ggplot2 themes
Ever notice the gray background on ggplot2? Well that's referred to as the default theme. There are other themes that can be called every time you createa a ggplot. Let's take a look:

The black & white theme
```{r}
library(ggplot2)

acadia = read.csv("/Users/james/Documents/Github/geog473-673/datasets/acadia.csv")

ggplot(acadia, aes(x=year, y=visitors)) +
    geom_line(col="yellow", size=5) + 
    geom_point(col="steelblue", size=3) + 
    geom_smooth(method="lm", col="firebrick") +
    labs(title="Acadia National Park Attendance", subtitle="Total Visitors per year", y="Visitors", x="Year", caption="National Park Database") +
    theme_bw()
  
```

The dark theme

```{r}
library(ggplot2)

acadia = read.csv("/Users/james/Documents/Github/geog473-673/datasets/acadia.csv")

ggplot(acadia, aes(x=year, y=visitors)) +
    geom_line(col="yellow", size=5) + 
    geom_point(col="steelblue", size=3) + 
    geom_smooth(method="lm", col="firebrick") +
    labs(title="Acadia National Park Attendance", subtitle="Total Visitors per year", y="Visitors", x="Year", caption="National Park Database") +
    theme_dark()
  
```

The light theme

```{r}
library(ggplot2)

acadia = read.csv("/Users/james/Documents/Github/geog473-673/datasets/acadia.csv")

ggplot(acadia, aes(x=year, y=visitors)) +
    geom_line(col="yellow", size=5) + 
    geom_point(col="steelblue", size=3) + 
    geom_smooth(method="lm", col="firebrick") +
    labs(title="Acadia National Park Attendance", subtitle="Total Visitors per year", y="Visitors", x="Year", caption="National Park Database") +
    theme_light()
  
```

The classic theme

```{r}
library(ggplot2)

acadia = read.csv("/Users/james/Documents/Github/geog473-673/datasets/acadia.csv")

ggplot(acadia, aes(x=year, y=visitors)) +
    geom_line(col="yellow", size=5) + 
    geom_point(col="steelblue", size=3) + 
    geom_smooth(method="lm", col="firebrick") +
    labs(title="Acadia National Park Attendance", subtitle="Total Visitors per year", y="Visitors",x="Year", caption="National Park Database") +
    theme_classic()
  
```


# Advanced Plotting - Synthesizing Shapefiles 

Often times, the spatial data that we want aren't in a nice, gridded lat/lon. The oblate spheroid that we call home presents some challenges when it comes to displaying spatial datasets. Often times, datasets like these are stored as separate entities - shapefiles & data tables. Fortunately, we have multiple avenues for working with this data. Let's check out a coastal flooding product that projects potential water levels above normal for each day. [coast-flood.udel.edu]

```{r}
#Load packages
library(RColorBrewer)
library(rgdal)
library(sp)
library(ggplot2)
library(ggmap)
library(scales)
library(viridis)

# Use the readOGR function to open a shapefile & constituents
coast.shp <- readOGR("/Users/james/Documents/Github/geog473-673/datasets/cfms_shapefiles/cfms_watersheds.shp")
class(coast.shp)
coast.shp@proj4string
```
This projection is **unique**. It's a transverse mercator with some specific lat_0 and lon_0 starting points. Notice the class of the shapefile - the underlying package controlling it's translation to R is the `sp` package -  A package providing classes and methods for spatial data: points, lines, polygons and grids. 

NOTE: Everytime you read in a shapefile like `cfms_watersheds.shp`, you MUST have the `.shx`, `.prj`, `.dbf`, etc. all within the SAME folder. Even though we are only keying an "opening" of the `.shp` file, `readOGR` is opening them all. 

ANOTHER NOTE: Notice the *@* symbol in `coast.shp@proj4string`. This is you query metadata associated with shapefiles. 

Back to plotting...
```{r}
plot(coast.shp)
# Open the dataset that corresponds to the water levels within the shapefile boxes 
coast.data <- read.csv("/Users/james/Documents/Github/geog473-673/datasets/cfms_shapefiles/water_levels.csv")
head(coast.data)
# now let's find the matching key - in this case, the matching key is the "station".
coast.shp$station
coast.data$station

# notice the difference above - let's reorder the data from the shapefile and the csv data by the station, otherwise
# merging will NOT work. 
coast.shp  = coast.shp[order(as.vector(coast.shp$station)),]
coast.data  = coast.data[order(as.vector(coast.data$station)),]

# merge together the shapefile data and the csv data based on common variable, here called 'station' - we MUST use the duplicateGeoms argument because there are multiple values for the same station name
merged.coast = sp::merge(coast.shp,coast.data,by='station', duplicateGeoms = TRUE)
class(merged.coast)
# remember that package::function is another way to call a specific function. I did this becuase other packages have 'merge' functions
# and I didn't want them to be confused. 

# Now let's use brewer.pal from RColorBrewer to create a blues color pallette
mycolours <- brewer.pal(8, "Blues")
mybreaks <- seq(0,6,0.5) 
# the data we're concerned with here is shortnamed maxpred - maximum predicted water level for the next 24 hours
cut(merged.coast$maxpred, mybreaks)
mycolourscheme <- mycolours[findInterval(merged.coast$maxpred, vec = mybreaks)]

```

The data is prepared, now we just need to plug in everything to plotting functions. First up is `spplot` from the `sp` package:

```{r}
spplot(merged.coast, "maxpred", par.settings = list(axis.line = list(col ="transparent")), main = "Projected Water Levels (Feet)", cuts = 5, col ="transparent", col.regions = mycolours)

```

Now we use the `tmap` function - very similar to `ggplot2`. `tmap` == Thematic Map Visualization. Thematic maps are geographical maps in which spatial data distributions are visualized. This package offers a flexible, layer-based, and easy to use approach to create thematic maps, such as choropleths and bubble maps. It is based on the grammar of graphics, and resembles the syntax of ggplot2.
```{r}
library(tmap)
tm_shape(merged.coast) + 
  tm_polygons(col='maxpred', title = "Projected Water Levels", palette = "Spectral") + tm_style("classic") + tm_scale_bar(position = c("left", "bottom")) 
```

Ok, so those are cool, but what about using `ggplot2`? It can be done, but we not out of the box...

Type the following and then hit tab - `merged.coast@` . Everything after the `@` are referred to as **slots**. `merged.coast` is just a `sp::SpatialPolygonsDataFrame` which holds polygons with attributes stored here as `slots`. The `merged.coast` slots are

- data
- polygons
- plotOrder
- bbox
- proj4string

The slots of primary interest are merged.coast@data (the geometry attributes) and merged.coast@polygons (the geometry features).  The attributes and features are related to each other by order, so the relationship is implicit.  Relationship attributes need to be explicit so that the geometry attributes can be joined with the geometry features.

```{r}
merged.coast@data$id <- rownames(merged.coast@data)
```
The above code explicitly identifies attribute rows by the .dbf offset

```{r}
newMerged <- fortify(merged.coast, region = "id")
```
The above code melts the polygons into points, tags each point with the id value of the corresponding attribute row, and tags each point with values from the polygon from which the point was derived. `fortify` is a `ggplot2` function that fortifies a model with data. 

`region = "id`" selects the feature attribute name to tag each row in the new data frame.  Each geometry feature offset gets the value from the feature attribute at the same offset.  In this case, it is merged.coast@data$id .  The attribute `newMerged$id` contains the mapped value.  If a different attribute were used (region="LEVEL3"), newMerged$id would contain the corresponding value of merged.coast@data$LEVEL3.

newMerged attributes include spatial coordinates (long and lat), group (coordinates having the same group belongs to the same polygon), and id (each id identifies a feature attribute tuple).

One of the remaining attributes is hole.  Each polygon in merged.coast@polygons is defined by one or more polygons. When defined by multiple polygons, the sub-polygons may be disjunct islands or holes. A hole part should remove geometry from its merged.coast@polgons instance.  When newMerged is created and individual polygons are melted, the hole state is retained, but this information is not used by ggplot2. Depending on the rendering sequence of the polygons, holes may overlay and obscure other polygons, or, more likely and more problematic, polygons are rendered without their fill removed from the hole, which obscures what should be seen through the hole.

```{r}
newdf <- merge(newMerged, merged.coast@data, by = "id")
```

The above code joins the points to their corresponding attributes and finalizes the data preparation.

```{r}
ggplot() +
  geom_polygon(data = newdf, aes(fill = maxpred, 
                                 x = long, 
                                 y = lat.x, 
                                 group = group)) + ggtitle("Projected Water Levels (Feet)") + theme(plot.title = element_text(hjust =0.5))


```

Alright so this gets us almost there. 










load(url("https://github.com/valentinitnelav/RandomScripts/blob/master/NaturalEarth.RData?raw=true"))



ggplot() +
    # add Natural Earth countries projected to Robinson, give black border and fill with gray
    geom_polygon(data=NE_countries_rob, aes(long,lat, group=group), colour="black", fill="gray80", size = 0.25)

ggplot() + geom_polygon(data=NE_box_rob, aes(x=long, y=lat), colour="black", fill="transparent", size = 0.25)

ggplot() + geom_path(data=NE_graticules_rob, aes(long, lat, group=group), linetype="dotted", color="grey50", size = 0.25)

ggplot() + geom_text(data = lbl.Y.prj, aes(x = X.prj, y = Y.prj, label = lbl), color="grey50", size=2)

ggplot() + geom_text(data = lbl.X.prj, aes(x = X.prj, y = Y.prj, label = lbl), color="grey50", size=2)

df = as.data.frame(projTemClim, xy=TRUE)
ggplot() + geom_raster(data=df, aes(x=x, y=y, fill = CRU_Global_1961.1990_Mean_Monthly_Surface_Temperature_Climatology))

ggplot() +    geom_raster(data=df, aes(x=x, y=y, fill = CRU_Global_1961.1990_Mean_Monthly_Surface_Temperature_Climatology)) +
    # add Natural Earth countries projected to Robinson, give black border and fill with gray
    geom_polygon(data=NE_countries_rob, aes(long,lat, group=group), colour="black", fill="transparent", size = 0.25) +
    # Note: "Regions defined for each Polygons" warning has to do with fortify transformation. Might get deprecated in future!
    # alternatively, use use map_data(NE_countries) to transform to data frame and then use project() to change to desired projection.
    # add Natural Earth box projected to Robinson
    geom_polygon(data=NE_box_rob, aes(x=long, y=lat), colour="black", fill="transparent", size = 0.25) +
    # add graticules projected to Robinson
    geom_path(data=NE_graticules_rob, aes(long, lat, group=group), linetype="dotted", color="grey50", size = 0.25) +
    # add graticule labels - latitude and longitude
    geom_text(data = lbl.Y.prj, aes(x = X.prj, y = Y.prj, label = lbl), color="grey50", size=2) +
    geom_text(data = lbl.X.prj, aes(x = X.prj, y = Y.prj, label = lbl), color="grey50", size=2) +
    # the default, ratio = 1 in coord_fixed ensures that one unit on the x-axis is the same length as one unit on the y-axis
    coord_quickmap(xlim=range(df$x), ylim=range(df$y)) +
    my_theme + my_fill +
    # remove the background and default gridlines
    

my_theme <- theme_void() + theme(panel.ontop=TRUE, panel.background=element_blank())
my_cols <- scale_color_distiller(palette='Spectral')
my_fill <- scale_fill_distiller(palette='Spectral')
ggplot(df, aes(y=y, x=x, fill=CRU_Global_1961.1990_Mean_Monthly_Surface_Temperature_Climatology)) +
    borders('world', xlim=range(df$x), ylim=range(df$y), colour='black') + my_theme + my_fill +
    coord_quickmap(xlim=range(df$x), ylim=range(df$y))
    
ggplot(df, aes(y=y, x=x, fill=CRU_Global_1961.1990_Mean_Monthly_Surface_Temperature_Climatology)) + geom_polygon() +
    borders('world', xlim=range(df$x), ylim=range(df$y), colour='black') + my_theme + my_fill +
    coord_map('lambert', lat0=30, lat1=65, xlim=c(-20, 39), ylim=c(19, 75))
    
    
library(rasterVis)
r=projTemClim
ggplot(r) + geom_tile(aes(fill = value)) + 
  scale_fill_distiller(palette="Spectral", na.value = "transparent") +
  my_theme  

library(mapview)
mapview(r, legend = TRUE)  


nam = brick("Downloads/NAM_CONUS_80km_20200107_0000.grib1")

# Band 34 is temperature at 450hpa
