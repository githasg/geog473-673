---
title: "Week5 - Spatial Points"
output: rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Reprojecting Raster data and plotting it with ggplot2

### Quick tutorial - ggplot2 themes
Ever notice the gray background on ggplot2? Well that's referred to as the default theme. There are other themes that can be called every time you createa a ggplot. Let's take a look:

The black & white theme
```{r}
library(ggplot2)

acadia = read.csv("/Users/james/Documents/Github/geog473-673/datasets/acadia.csv")

ggplot(acadia, aes(x=year, y=visitors)) +
    geom_line(col="yellow", size=5) + 
    geom_point(col="steelblue", size=3) + 
    geom_smooth(method="lm", col="firebrick") +
    labs(title="Acadia National Park Attendance", subtitle="Total Visitors per year", y="Visitors", x="Year", caption="National Park Database") +
    theme_bw()
  
```

The dark theme

```{r}
library(ggplot2)

acadia = read.csv("/Users/james/Documents/Github/geog473-673/datasets/acadia.csv")

ggplot(acadia, aes(x=year, y=visitors)) +
    geom_line(col="yellow", size=5) + 
    geom_point(col="steelblue", size=3) + 
    geom_smooth(method="lm", col="firebrick") +
    labs(title="Acadia National Park Attendance", subtitle="Total Visitors per year", y="Visitors", x="Year", caption="National Park Database") +
    theme_dark()
  
```

The light theme

```{r}
library(ggplot2)

acadia = read.csv("/Users/james/Documents/Github/geog473-673/datasets/acadia.csv")

ggplot(acadia, aes(x=year, y=visitors)) +
    geom_line(col="yellow", size=5) + 
    geom_point(col="steelblue", size=3) + 
    geom_smooth(method="lm", col="firebrick") +
    labs(title="Acadia National Park Attendance", subtitle="Total Visitors per year", y="Visitors", x="Year", caption="National Park Database") +
    theme_light()
  
```

The classic theme

```{r}
library(ggplot2)

acadia = read.csv("/Users/james/Documents/Github/geog473-673/datasets/acadia.csv")

ggplot(acadia, aes(x=year, y=visitors)) +
    geom_line(col="yellow", size=5) + 
    geom_point(col="steelblue", size=3) + 
    geom_smooth(method="lm", col="firebrick") +
    labs(title="Acadia National Park Attendance", subtitle="Total Visitors per year", y="Visitors",x="Year", caption="National Park Database") +
    theme_classic()
  
```

The void theme

```{r}
library(ggplot2)

acadia = read.csv("/Users/james/Documents/Github/geog473-673/datasets/acadia.csv")

ggplot(acadia, aes(x=year, y=visitors)) +
    geom_line(col="yellow", size=5) + 
    geom_point(col="steelblue", size=3) + 
    geom_smooth(method="lm", col="firebrick") +
    labs(title="Acadia National Park Attendance", subtitle="Total Visitors per year", y="Visitors",x="Year", caption="National Park Database") +
    theme_void()
  
```

# Advanced Plotting - Synthesizing Shapefiles 

Often times, the spatial data that we want aren't in a nice, gridded lat/lon. The oblate spheroid that we call home presents some challenges when it comes to displaying spatial datasets. Often times, datasets like these are stored as separate entities - shapefiles & data tables. Fortunately, we have multiple avenues for working with this data. Let's check out a coastal flooding product that projects potential water levels above normal for each day. [coast-flood.udel.edu]

```{r}
#Load packages
library(RColorBrewer)
library(rgdal)
library(sp)
library(ggplot2)
library(ggmap)
library(scales)
library(viridis)

# Use the readOGR function to open a shapefile & constituents
coast.shp <- readOGR("/Users/james/Documents/Github/geog473-673/datasets/cfms_shapefiles/cfms_watersheds.shp")
class(coast.shp)
coast.shp@proj4string
```
This projection is **unique**. It's a transverse mercator with some specific lat_0 and lon_0 starting points. Notice the class of the shapefile - the underlying package controlling it's translation to R is the `sp` package -  A package providing classes and methods for spatial data: points, lines, polygons and grids. 

NOTE: Everytime you read in a shapefile like `cfms_watersheds.shp`, you MUST have the `.shx`, `.prj`, `.dbf`, etc. all within the SAME folder. Even though we are only keying an "opening" of the `.shp` file, `readOGR` is opening them all. 

ANOTHER NOTE: Notice the *@* symbol in `coast.shp@proj4string`. This is you query metadata associated with shapefiles. 

Back to plotting...
```{r}
plot(coast.shp)
# Open the dataset that corresponds to the water levels within the shapefile boxes 
coast.data <- read.csv("/Users/james/Documents/Github/geog473-673/datasets/cfms_shapefiles/water_levels.csv")
head(coast.data)
# now let's find the matching key - in this case, the matching key is the "station".
coast.shp$station
coast.data$station

# notice the difference above - let's reorder the data from the shapefile and the csv data by the station, otherwise
# merging will NOT work. 
coast.shp  = coast.shp[order(as.vector(coast.shp$station)),]
coast.data  = coast.data[order(as.vector(coast.data$station)),]

# merge together the shapefile data and the csv data based on common variable, here called 'station' - we MUST use the duplicateGeoms argument because there are multiple values for the same station name
merged.coast = sp::merge(coast.shp,coast.data,by='station', duplicateGeoms = TRUE)
class(merged.coast)
# remember that package::function is another way to call a specific function. I did this becuase other packages have 'merge' functions
# and I didn't want them to be confused. 

# Now let's use brewer.pal from RColorBrewer to create a blues color pallette
mycolours <- brewer.pal(8, "Blues")
mybreaks <- seq(0,6,0.5) 
# the data we're concerned with here is shortnamed maxpred - maximum predicted water level for the next 24 hours
cut(merged.coast$maxpred, mybreaks)
mycolourscheme <- mycolours[findInterval(merged.coast$maxpred, vec = mybreaks)]

```

The data is prepared, now we just need to plug in everything to plotting functions. First up is `spplot` from the `sp` package:

```{r}
spplot(merged.coast, "maxpred", par.settings = list(axis.line = list(col ="transparent")), main = "Projected Water Levels (Feet)", cuts = 5, col ="transparent", col.regions = mycolours)

```

Now we use the `tmap` function - very similar to `ggplot2`. `tmap` == Thematic Map Visualization. Thematic maps are geographical maps in which spatial data distributions are visualized. This package offers a flexible, layer-based, and easy to use approach to create thematic maps, such as choropleths and bubble maps. It is based on the grammar of graphics, and resembles the syntax of ggplot2.
```{r}
library(tmap)
tm_shape(merged.coast) + 
  tm_polygons(col='maxpred', title = "Projected Water Levels", palette = "Spectral") + tm_style("classic") + tm_scale_bar(position = c("left", "bottom")) 
```

Ok, so those are cool, but what about using `ggplot2`? It can be done, but we not out of the box...

Type the following and then hit tab - `merged.coast@` . Everything after the `@` are referred to as **slots**. `merged.coast` is just a `sp::SpatialPolygonsDataFrame` which holds polygons with attributes stored here as `slots`. The `merged.coast` slots are

- data
- polygons
- plotOrder
- bbox
- proj4string

The slots of primary interest are merged.coast@data (the geometry attributes) and merged.coast@polygons (the geometry features).  The attributes and features are related to each other by order, so the relationship is implicit.  Relationship attributes need to be explicit so that the geometry attributes can be joined with the geometry features.

```{r}
merged.coast@data$id <- rownames(merged.coast@data)
```
The above code explicitly identifies attribute rows by the .dbf offset

```{r}
newMerged <- fortify(merged.coast, region = "id")
```
The above code melts the polygons into points, tags each point with the id value of the corresponding attribute row, and tags each point with values from the polygon from which the point was derived. `fortify` is a `ggplot2` function that fortifies a model with data. 

`region = "id`" selects the feature attribute name to tag each row in the new data frame.  Each geometry feature offset gets the value from the feature attribute at the same offset.  In this case, it is merged.coast@data$id .  The attribute `newMerged$id` contains the mapped value.  If a different attribute were used (region="LEVEL3"), newMerged$id would contain the corresponding value of merged.coast@data$LEVEL3.

newMerged attributes include spatial coordinates (long and lat), group (coordinates having the same group belongs to the same polygon), and id (each id identifies a feature attribute tuple).

One of the remaining attributes is hole.  Each polygon in merged.coast@polygons is defined by one or more polygons. When defined by multiple polygons, the sub-polygons may be disjunct islands or holes. A hole part should remove geometry from its merged.coast@polgons instance.  When newMerged is created and individual polygons are melted, the hole state is retained, but this information is not used by ggplot2. Depending on the rendering sequence of the polygons, holes may overlay and obscure other polygons, or, more likely and more problematic, polygons are rendered without their fill removed from the hole, which obscures what should be seen through the hole.

```{r}
newdf <- merge(newMerged, merged.coast@data, by = "id")
```

The above code joins the points to their corresponding attributes and finalizes the data preparation.

```{r}
ggplot() +
  geom_polygon(data = newdf, aes(fill = maxpred, 
                                 x = long, 
                                 y = lat.x, 
                                 group = group)) + ggtitle("Projected Water Levels (Feet)") + theme(plot.title = element_text(hjust =0.5))


```

Alright so this gets us almost there. Clearly this is a weird projection with the lat/lon values in meters rather than degrees. Let's try and normalize it and then add in our **world** shapefiles from the **datasets** folder. In order to do this, we'll need to use `geom_sf` from `ggplot2`. This enables us to plot `sf` objects. `sf` is a package for Simple Features. It's one of the other big players for spatial data wrangling in R that a lot of other, fancier packages that we use in this class are built on. We'll need to load in `sf` before we can convert our shapefile into an `sf` object. 

```{r}
library(sf)
states <- readOGR("/Users/james/Documents/Github/geog473-673/datasets/ne_10m_admin_1_states_provinces/ne_10m_admin_1_states_provinces.shp")
class(states)
states = st_as_sf(states)
class(states)
gg_merged = st_as_sf(merged.coast)
pal = brewer.blues(9)
# note theme_void is NECESSARY
ggplot(data = states) + geom_sf() + theme_void() +
  geom_sf(data = gg_merged, aes(fill = maxpred)) +
  coord_sf(xlim = c(-76.1, -74.7), ylim = c(38.3,40), expand = FALSE) +
  scale_fill_distiller(palette = "Blues", direction= 1)

```
Looks pretty good even though the shapefile isn't quite as sharp as we'd like. Besides the shapefile which we added to the plot via `geom_sf()`, take notice of the `theme_void()`...this plot will NOT WORK without `theme_void()`. There is ongoing github discussions with some of the developers at `ggplot2` to figure out why, but for now just make sure you use `theme_void` to add shapefiles to the same plot in R and have them work properly. Also take note of the `scale_fill_distiller` function. This is an easy way to throw in a `RColorbrewer` color pallette. In this case we used the Blues colorpallete since we're dealing with water but you can make it any `RColorbrewer` pallette you want. Also notice the `direction=1`. This reverses the order of the blues color pallette. I can't explain why it's not `-1`...Sidenote - you can also use `scale_fill_viridis()` which has some different default pallettes such as - “magma”, “plasma”, and “inferno”. 



